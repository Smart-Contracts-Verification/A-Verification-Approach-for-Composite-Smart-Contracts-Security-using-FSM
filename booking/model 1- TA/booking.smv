MODULE main

VAR
	
  createFlights:		boolean;
  addFlight:		boolean;
  additionCounterOne:		boolean;
  finishcreateFlights:		boolean;

  SearchflightPRICE:		boolean;
  guardSearchflightPRICE:		boolean;
  DguardSearchflightPRICE:		boolean;
  startloopS:		boolean;
  loopconditionS:		boolean;
  DloopconditionS:		boolean;
  ifconditionS:		boolean;
  DifconditionS:		boolean;
  loopincreS:		boolean;
  backtoloopS:		boolean;
  ifconditionS1:		boolean;
  DifconditionS1:		boolean;
  return:		boolean;
  revert:		boolean;

  getFlightbyID:		boolean;
  guardfunctiongetFlightbyID:		boolean;
  DguardfunctiongetFlightbyID:		boolean;
  startloop1:		boolean;
  loop1condition:		boolean;
  Dloop1condition:		boolean;
  return1:		boolean;
  backtoloop1:		boolean;
  ifcondition1:		boolean;
  Difcondition1:		boolean;

  BookFLIGHT:		boolean;
  guardBookFLIGHT:		boolean;
  DguardBookFLIGHT:		boolean;
  loop2condition :		boolean;
  Dloop2condition :		boolean;
  ifcondition2:		boolean;
  Difcondition2:		boolean;
  loop2incre:		boolean;
  backtoloop2:		boolean;

Flight_status	: boolean;
	state 		: {invoke, functioncreateFlights, AddFlight, addition, functionSearchflightPRICE, setV1f, loop0, loop0condition, loop0incre, setV2f, returnfuntionSearchflightPRICE, revertfuntionSearchflightPRICE, functiongetFlightbyID, loop1, Loop1condition, Loop1incre, returngetFlightbyID, setV1g, functionBookFLIGHT, loop2, Loop2condition, Loop2incre, setV1b
}; 
	counter 	: unsigned word[3];	
	Total_Price	: unsigned word[3];
	i		: unsigned word[3];
	j		: unsigned word[3];
	k		: unsigned word[3];
	Flight_Price	: unsigned word[3];
	Pmin		: unsigned word[3];
	id		: unsigned word[3];
	idF		: unsigned word[3];


INIT
		( id = 0ud3_1 ) &
		( idF= 0ud3_1 ) &
		( i = 0ud3_0 ) &
		( j= 0ud3_0 ) &
		( k= 0ud3_0 ) &
		( counter = 0ud3_0 ) &
		( Flight_status = TRUE ) &
		( Pmin = 0ud3_0 ) &
		( (state) = (invoke) ) &
		( (Total_Price) = (0ud3_6) ) &
		( (NuV_responseHash) = (0ud3_0) );

INVAR
		( (( (state) = (functioncreateFlights) )) -> ( createFlights) ) &
		( (( (state) = (functiongetFlightbyID) )) -> (getFlightbyID) ) &
		( (( (state) = (functionSearchflightPRICE) )) -> (BAUC_finishsub) ) &
		( (( (state) = (functionBookFLIGHT) )) -> ( BookFLIGHT) ) &
		( (( (state) = (NuI10) )) -> (BAUC_finishadd1) ) &
		( (( (state) = (NuI3) )) -> (BAUC_aMinusb) ) &
		( (( (state) = (NuI8) )) -> (BAUC_aPlusb1) ) &
		( (( (state) = (NuI1) )) -> (BAUC_add) ) &
		( (( (state) = (NuI2) )) -> (BAUC_sub) ) &
		( (( (state) = (NuI9) )) -> (BAUC_finishsub1) );





	
	init(state) := invoke;
	next(state) := case
						state =invoke : {functioncreateFlights, functiongetFlightbyID, functionSearchflightPRICE, functionBookFLIGHT};
						state= functioncreateFlights : AddFlight;
						state= AddFlight : addition;
						state= addition  : invoke;
						state= functiongetFlightbyID & id >  0ud3_0 : loop1;
						state= functiongetFlightbyID & id <= 0ud3_0 : invoke;
						state= loop1 & j <= counter : Loop1condition;
						state= loop1 & j > counter  : invoke;
						state= Loop1condition & idF = id : setV1g;
						state= Loop1condition & idF != id : Loop1incre;
						state= setV1g : invoke;
						state= Loop1incre : loop1;
						state= functionSearchflightPRICE & Total_Price >  0ud3_0 : setV1f;
						state= functionSearchflightPRICE & Total_Price <= 0ud3_0 : invoke;
						state= setV1f : loop0 ;
						state= loop0 & i <= counter: loop0condition;
						state= loop0 & i > counter : invoke;
						state= loop0 & Total_Price >= Pmin : returnfuntionSearchflightPRICE;
						state= loop0 & Total_Price < Pmin  : revertfuntionSearchflightPRICE;
						state= loop0condition & Flight_Price <= Pmin & Flight_status = TRUE : setV2f ;
						state= loop0condition & Flight_Price > Pmin | Flight_status != TRUE:  loop0incre;
						state= setV2f : loop0incre;
						state= loop0incre : loop0;
						state= returnfuntionSearchflightPRICE : invoke;
						state= revertfuntionSearchflightPRICE : invoke;
						state= functionBookFLIGHT & id > 0ud3_0  :loop2;
						state= functionBookFLIGHT & id <= 0ud3_0 : invoke;
						state= loop2 & k <= counter: Loop2condition;
						state= loop2 & k > counter: invoke;
						state= Loop2condition & idF = id & Flight_status = TRUE : setV1b;
						state= Loop2condition & idF != id & Flight_status != TRUE : Loop2incre;
						state= setV1b : Loop2incre;
						state= Loop2incre : loop2;
						TRUE : state;
				 esac;



MODULE main

	VAR
		state		:		{NuI1, NuI2, NuI3, NuI4, NuI5, NuI6, NuI7, NuI8, NuI9, NuI10};
		bauc	:	BAUC(state);

	DEFINE
		BAUC_aPlusb		:=		bauc.NuPaPlusb;
		BAUC_finishadd		:=		bauc.NuPfinishadd;
		BAUC_finishsub		:=		bauc.NuPfinishsub;
		BAUC_aMinusb1		:=		bauc.NuPaMinusb1;
		BAUC_finishadd1		:=		bauc.NuPfinishadd1;
		BAUC_aMinusb		:=		bauc.NuPaMinusb;
		BAUC_aPlusb1		:=		bauc.NuPaPlusb1;
		BAUC_add		:=		bauc.NuPadd;
		BAUC_sub		:=		bauc.NuPsub;
		BAUC_finishsub1		:=		bauc.NuPfinishsub1;


	INVAR
		( (( (state) = (NuI7) )) -> (BAUC_aPlusb) ) &
		( (( (state) = (NuI6) )) -> (BAUC_finishadd) ) &
		( (( (state) = (NuI5) )) -> (BAUC_finishsub) ) &
		( (( (state) = (NuI4) )) -> (BAUC_aMinusb1) ) &
		( (( (state) = (NuI10) )) -> (BAUC_finishadd1) ) &
		( (( (state) = (NuI3) )) -> (BAUC_aMinusb) ) &
		( (( (state) = (NuI8) )) -> (BAUC_aPlusb1) ) &
		( (( (state) = (NuI1) )) -> (BAUC_add) ) &
		( (( (state) = (NuI2) )) -> (BAUC_sub) ) &
		( (( (state) = (NuI9) )) -> (BAUC_finishsub1) );
