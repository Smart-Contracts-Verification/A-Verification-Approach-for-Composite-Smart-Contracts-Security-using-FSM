MODULE main

VAR

credit:unsigned word[3];
amount:unsigned word[3];
owner:boolean;

_current_state:{invoke,function_withdrawallEther,function_withdraw,function_kill,function_forward,sending_ether_transfer,requirecondition,txorigin,Dtxorigin,ifcondition,creditEqualGamount,creditDamount,sending_ether_call, subtraction,delegatecall,Ddelegatecall,selfdestruct,public};
	
ASSIGN

init(_current_state):=invoke;
next(_current_state):=case
(_current_state=invoke): {function_withdrawallEther,function_withdraw, function_kill, function_forward};
(_current_state=function_kill):public;
(_current_state=function_withdrawallEther):public;
(_current_state=function_withdraw):public;
(_current_state=function_forward):public;
(_current_state=public):{selfdestruct,requirecondition,ifcondition};
(_current_state=selfdestruct):invoke;
(_current_state=requirecondition):{delegatecall,Ddelegatecall,txorigin,Dtxorigin};
(_current_state=txorigin):sending_ether_transfer;
(_current_state=sending_ether_transfer):invoke;
(_current_state=Dtxorigin):invoke;
(_current_state=delegatecall):invoke;
(_current_state=Ddelegatecall):invoke;
(_current_state=ifcondition) & (credit >= amount):creditEqualGamount;
(_current_state=ifcondition) & ( credit < amount):creditDamount;
(_current_state=creditDamount) :invoke;
(_current_state=creditEqualGamount) :sending_ether_call;
(_current_state=sending_ether_call):subtraction;
(_current_state=subtraction):invoke;

!(_current_state=invoke) & !(_current_state=function_kill)& !(_current_state=function_withdrawallEther)& !(_current_state=function_withdraw)& !(_current_state=function_forward)& !(_current_state=public)
& !(_current_state=selfdestruct) & !(_current_state=requirecondition) & !(_current_state=txorigin)& !(_current_state=sending_ether_transfer)& !(_current_state=Dtxorigin)& !(_current_state=delegatecall)
& !(_current_state=Ddelegatecall)& !((_current_state=ifcondition) & (credit >= amount)) & !((_current_state=ifcondition) & ( credit < amount))& !(_current_state=creditDamount)
& !(_current_state=creditEqualGamount)& !(_current_state=sending_ether_call)& !(_current_state=subtraction): _current_state;
esac;

init(owner):=TRUE;
next(owner):=case
TRUE:owner;
esac;


init(credit):=0ud3_4;
next(credit):=case
(_current_state=subtraction): credit - amount;
!(_current_state=subtraction): credit;
esac;

init(amount):=0ud3_2;
next(amount):=case
(_current_state=function_withdraw): amount + 0ud3_1;
!(_current_state=function_withdraw): amount;
esac;


--Spec_1 check reentrancy vulnerability
CTLSPEC NAME Reentrancy_Vulnerability :=AG ( (_current_state = function_forward) | (_current_state = function_withdrawallEther)| (_current_state=function_withdraw) | (_current_state= function_kill)  ->  EF (   AG ((_current_state = sending_ether_call) -> AF (_current_state = subtraction)) ) ) 

--Spec_2 check Underflow vulnerability
CTLSPEC NAME Underflow_Vulnerability := AG ((_current_state = function_withdraw & amount > credit ) -> AF _current_state = subtraction)   

--Spec_3 check delegatecall vulnerability
CTLSPEC NAME delegatecall_Vulnerability := AG(EF(_current_state = delegatecall))

--Spec_4 check tx.origin vulnerability
CTLSPEC NAME txorigin_Vulnerability := EG((_current_state = requirecondition) |(_current_state = ifcondition)->  EX(_current_state = txorigin))

--Spec_5 check SELFDESTRUCT vulnerability
CTLSPEC NAME selfdestruct_Vulnerability := AG((_current_state = public) -> EF(_current_state =selfdestruct))

--Spec_6 check user-defined Spec
CTLSPEC NAME user_spec :=AG((_current_state= txorigin) -> AX (_current_state= sending_ether_transfer))